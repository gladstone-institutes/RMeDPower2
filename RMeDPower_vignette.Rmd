---
title: "*RMeDPower2*: helping design and analyses of data from repeated measures experiments" 
author:
- name: Min-Gyoung Shin
  affiliation: Gladstone Institutes
  email: mingyoung.shin@gladstone.ucsf.edu
- name: Reuben Thomas
  affiliation: Gladstone Institutes
  email: reuben.thomas@gladstone.ucsf.edu
package: RMeDPower
output:
  BiocStyle::html_document
abstract: |
  Biomedical research very often involves data generated from repeated measures experiments. RMeDPower2 is an R package that provides complete functionality to analyse data coming from repeated measures experiments, i.e., where one has repeated measures from the same biological/independent units or samples. RMeDPower2 helps test the modeling assumptions one makes, identify outlier observations, outlier units at different levels of the design, estimates statistical power or perform sample size calculations, estimate parameters of interest and also to visualize the association being tested. The functionality is limited to testing associations of one predictor (continuous or categorical, e.g., disease status or brain pathology) along with one another covariate (e.g., gender status) in the context of hierarchical or crossed experimental designs. This vignette illustrates the use of this package in multiple contexts relevant to biomedical research. 
  
  RMeDPower2 defines the experimental design for the data, probability model of the data generating distribution and necessary parameters required for sample size calculation using convenient S4 class objects. It uses these objects in one framework that brings together the functionality implemented in multiple R packages - lme4 (implementation of linear mixed effects models), influence.ME (identification of outlier units), EnvStats (identification of outlier observations), DHARMa (testing of modeling assumptions for non-normal distributions), simr (sample-size calculations) and tidyverse (data manipulation and visualization).
vignette: |
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Getting started

## Installing `RMeDPower2`
`RMeDPower2` can be installed using the following commands
```{r eval=FALSE}
install.packages("devtools")
library(devtools)
install_github('gladstone-institutes/RMeDPower2', build_vignettes=TRUE)
##load the library
library(RMeDPower2)
```

## Quick tutorial
The workflow can be accomplished in 5 main steps.

### Input data
Read-in the input data as a data frame
```{r}
library(RMeDPower2)
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/cell_assay_data/"

data <- read.csv(paste0(template_dir, "cell_size_data.csv"), header = T)
```


### Specify design, model and power parameters
1. Use a text editor to modify the template jsonfile capturing the design file and read in this file.
```{r}
design <- readDesign(paste0(template_dir,"design_cell_assay.json"))
```
2. Use a text editor to modify the template jsonfile capturing the error probability model file and read in this file.
```{r}
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
```
3. Use a text editor to modify the template jsonfile capturing the power parameters file and read in this file.
```{r}
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
```

### Diagnose data and model
1. Diagnose the data and model, test model assumptions, identify outlier observations, outlier biological/independent units
```{r eval=FALSE}
diagnose_res <- diagnoseDataModel(data, design, model)
```
2. Modify design objects (e.g., remove outliers), model objects (e.g., change probability distribution assumption) if needed based on output of step 1 above.
```{r eval=FALSE}
diagnose_res_update <- diagnoseDataModel(data_update, design_update, model_update)
```
3. Repeat steps 1 and 2 until the models assumptions are met

### Statistical power estimation
Run sample-size calculations
```{r eval=FALSE}
power_res <- calculatePower(data, design, model, power_param)
```

### Estimate parameters of interest
Estimate and visualize parameters of interest.
```{r eval=FALSE}
estimate_res <- getEstimatesOfInterest(data, design, model)
```
## Input data
Users will have to ensure that the input data is a table with rows representing the  individual observations or responses and columns representing not only the corresponding predictor/independent variables but also other variables that capture the hierarchical or crossed design of how the data was generated. It is important that the columns have names or headers - these column names will be used to define the relevant S4 class objects. 

For example, below illustrates the input data from a cellular assay where each of the 2,588 observations represents a measurement of size (`cell_size2`) of a single cell, from a given cell line (`line`) that is either from a control or disease condition (`classification`) and is measured in a given experimental batch (`experiment`).

```{r echo=FALSE} 
suppressPackageStartupMessages(require(dplyr)) 
suppressPackageStartupMessages(library(RMeDPower2))
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/cell_assay_data/"

data <- read.csv(paste0(template_dir, "cell_size_data.csv"), header = T) %>%
  select(experiment, line, classification, cell_size2) %>%
  mutate(experiment = as.factor(experiment), line = as.factor(line), classification = as.factor(classification))

str(data)
```

## Three key classes of `RMeDPower2`
### `RMeDesign` S4 class
The underlying design for the data will be stored in an object of this class. The slots of this class are:

1. `response_column`: character that is the column name in the input data table that captures the responses or individual observations. This has to be set by the user.

2. `covariate`: character that is the column name in the input data table that captures the covariate information. This will be used as a fixed effect in the mixed effects model of the data. This slot is set to `NULL` if there are no covariates.

3. `condition_column`: character that is the column name in the input data table that captures the predictor/independent variable information. This will be used as a fixed effect in the mixed effects model of the data.This has to be set by the user.

4. `experimental_columns`: character vector that represents the column names in the input data table that captures the experimental variables of the design. These will be used as random effects in the mixed effects model of the data. The order of the names in this character vector is important. The first element captures the top hierarchical level of the design, the second element the next level of the hierarchy and so on. The hierarchy is explicitly modeled in the specification of the mixed effects models. The hierarchy will not be modeled for variables specified in the `crossed_columns` slot (see below). This has to be set by the user. 

5. `condition_is_categorical`: logical value equal to TRUE if the variable in the `condition_column` is to be considered as a categorical variable and is equal to FALSE otherwise. Defaults to TRUE.

6. `crossed_columns`: character vector that represents the column names in the input data table that are a subset of the values in `experimental_columns` representing crossed factors. Defaults to `NULL`.

7. `total_column`: character that is the column name in the input table that will be used to offset values in the mixed effects models. Useful for modeling count data. Defaults to `NULL`.
  
8. `outlier_alpha`: numeric value that is the p-value threshold used to identify outlier observations. Defaults to 0.05. 

9. `na_action`: character equal to _complete_ or _unique_. To be used in the context where the input data has multiple responses that will each be sequentially modeled. _complete_ refers to the situation where outlier observations identified for one response will also be identified as outliers for all the other responses while _unique_ refers to the situation where the outlier observations identified for one response will only be used for the model of that particular response. Defaults to _complete_.

We can create an object of class `RMeDesign` using the function.
```{r}
design <- new("RMeDesign")
print(design)
```

In practice, for a given data set the design can be input from a jsonfile. The user can use a text editor to modify the `design_template.json` file available with the package to input the relevant information based on the column names of the input data. For example, the design for the cell size data referred to above can be read using the function `readDesign`,
```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/cell_assay_data/"

design <- readDesign(paste0(template_dir,"design_cell_assay.json"))
print(design)
```
### `ProbabilityModel` S4 class
The error probability distribution is specified by two slots in objects of the `ProbabilityModel` class.

1. `error_is_non_normal`: logical value that is TRUE if the underlying probability distribution is not assumed to be Normal and is FALSE otherwise.

2. `family_p`: character value that specifies the probability distribution. Accepted values are _poisson_(`=poisson(link="log")`), _binomial_(`=binomial(link="logit")`), _bionomial_log_(`=binomial(link="log")`), _Gamma_log_(`=Gamma(link="log")`), _Gamma_(`=Gamma(link="inverse")`), _negative_binomial_. Defaults to `NULL`.

```{r}
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
print(model)
```
### `PowerParams` S4 class
The parameters necessary for sample-size estimation are stored in the following slots of the `PowerParams` class.

 1. `target_columns`: character vector with column names of experimental variables for which the sample-size estimation is to be performed
2. `power_curve`: numeric 1 or 0. 1: Power simulation over a range of sample sizes or levels. 0: Power calculation over a single sample size or a level. Defaults to 1.
3. `nsimn`: The number of simulations to estimate power. Defaults to 10.
4. `levels`: numeric 1 or 0. 1: Amplify the number of corresponding target parameter. 0: Amplify the number of samples from the corresponding target parameter, ex) If target_columns = c("experiment","cell_line") and if you want to expand the number of experiment and sample more cells from each cell line, set levels = c(1,0).
5. `max_size`: Maximum levels or sample sizes to test. Default if set to `NULL` equals the current level or the current sample size x 5. ex) If max_levels = c(10,5), it will test upto 10 experiments and 5 cell lines.
6. `alpha`: Type I error for sample-size estimation. Defaults to 0.05.
7. `breaks`: Levels /sample sizes of the variable to be specified along the power curve. Default if set to `NULL` equals max(1, round( the number of current levels / 5 ))
8. `effect_size`: If you know the effect size of your condition variable, the effect size can be provided as a parameter. Default set to `NULL`, that is, if the effect size is not provided, it will be estimated from your data,
9. `icc`: Intra-class coefficients for each of the experimental variables. Used only in the situation when `error_is_non_normal=FALSE` and when the data does not allow variance component estimation 

```{r}
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
print(power_param)
```

## Three key functions of `RMeDPower2`

### `diagnoseDataModel(data, design, model)` function
Tests the model assumptions using quantile-quantile, residuals vs fitted and residuals versus predicted plots, transforms responses if feasible and identifies outlier observations and also outlier experimental units

### `calculatePower(data, design, model, power_param)` function
Performs sample-size calculations for given experimental design/target variable

### `getEstimatesOfInterest(data, design, model)` function
Estimates parameter of interest and also plots the resulting association with predictor of interest using residuals from the model that removes the effects of the modeled experimental variables

# Application examples
## Plate assays


iPSC lines from control and patient derived iPSCs from sALS patients were obtained through the Answer ALS (AALS) consortium36 . AALS is the largest repository of ALS patient samples, and contains publicly available patient-specific iPSCs and multi-OMIC data from motor neurons derived from those iPSCs—including RNA Seq, proteomics and whole genome sequence data— all of which is matched with longitudinal clinical data (https://dataportal.answerals.org/home)36. 

```{r ALS, echo=FALSE, fig.align = "center", fig.cap='iPSC-derived ALS cell lines', fig.wide=TRUE, echo=FALSE}
knitr::include_graphics("https://answerals.org/wp-content/uploads/2018/02/Snip20170905_16-1.png")
```

We used 6 control lines and 4 sALS lines. We differentiated each line into motor neurons, transduced with a morphology marker and imaged on day ~25 using RM37-45 as previously
described36. Images were processed and the soma size of neurons were captured using contour ellipse46 function adapted for use in python (https://www.python.org/).

```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/cell_assay_data/"

data <- read.csv(paste0(template_dir, "cell_size_data.csv"), header = T)
design <- readDesign(paste0(template_dir,"design_cell_assay.json"))
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
```

Diagnose the data and the model
```{r}
diagnose_res <- diagnoseDataModel(data, design, model)
```

Check for outlier experimental batches
```{r}
##see which experimental columns correspond to which variable
print(design@experimental_columns)
print(diagnose_res$cooks_distance_experimental_column1)
```

It looks like `experiment3` batch seems like an outlier. Now, check for outlier cell lines
```{r}
print(diagnose_res$cooks_distance_experimental_column2)
```

The qq plots of the residuals resulting from log transformation of the cell-size responses and the removal of outliers seems to deviate least from normality (though they still do seem non-normal). In any case, we will use these data for parameter estimation. 

```{r}
design_update <- design
data_update <- diagnose_res$Data_updated
print(colnames(data_update))
design_update@response_column <-  "cell_size2_logTransformed_noOutlier"
estimate_res <- getEstimatesOfInterest(data_update, design_update, model)
##print model summary output
print(estimate_res[[1]])
```
We can also perform calculate the number of experimental batches needed to estimate the  observed differences in soma size.  
```{r eval=FALSE}
power_res <- calculatePower(data_update, design_update, model, power_param)
```


## single-cell RNA-seq assays
We will use data derived from the single-nuclei RNA-seq experiments performed in Koutsodendris et al. paper. One of the goals in these experiments was to assess the effect of the APOE gene isoform on brain pathology in a mouse model of Alzheimer's Disease (AD). Specifically, APOE4 gene isoform is an known risk factor for this disease in humans compared to those with the APOE3 gene isoform. The paper tests the role of expression of neuronal APOE expression in the development of disease pathology. The design of the data involved order 1000 cells derived from the hippocampus brain region of 4 mice with the human APOE4 gene knocked-in the mouse Apoe locus and 4 other mice (called E4-KI-Syn1-Cre) with the human APOE4 gene also  knocked-in in the same mouse. However, the APOE4 expression in these mice is knocked out specifically in the neurons. The single cell data allowed the identification of multiple clusters or cell-types including cluster 7 representing a group of excitatory neurons consisted of nuclei.

```{r singleCell, echo=FALSE, fig.align = "center", fig.cap='single nuclei RNA sequencing', fig.wide=TRUE, echo=FALSE}
knitr::include_graphics("https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs43587-023-00368-3/MediaObjects/43587_2023_368_Fig5_HTML.png?as=webp")
```

### Cell-type/cluster associations
We can first ask the question whether or not the proportion of nuclei derived from the APOE4-KI mice are different in cluster 7 compared to those derived from the APOE4-KI-Syn1-Cre mice. More exactly, we want to test whether or not there is a difference in the log odds of cluster membership in cluster 7 among the APOE4-KI mice versus the APOE4-KI-Syn1-Cre. The data consists of the number of nuclei per animal present in the cluster and also the total number of nuclei that were isolated from this animal.

#### Associations with genotype
```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/single_cell_data/celltype_proportions_with_genotype/"
data <- read.csv(paste0(template_dir, "apoe_associated_cell_proportions.csv"), header = T)
head(data)

##load the design
design <- readDesign(paste0(template_dir,"design_celltype1.json"))
print(design)

##load the probability model
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
print(model)

##load the relevant power parameters
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
print(power_param)
```


Now, we will diagnose the data and the model.
```{r}
diagnose_res <- diagnoseDataModel(data, design, model)
```

We can now estimate the log odds ratio of interest.
```{r}
estimate_res <- getEstimatesOfInterest(data, design, model)
print(estimate_res[[1]])
```

And estimate whether or not statistical power we have to estimate the given observed association with varying number of mice per group.

```{r eval=TRUE}
print(power_param@target_columns)
power_res <- calculatePower(data, design, model, power_param)
```

#### Associations with hippocampus volume
Next, we can first ask the question whether or not the proportion of nuclei derived from each of the  mice are associated with their hippocampus volumes. Note, more neuro-degeneration is linked to smaller hippocampus volumes. More exactly, we want to test whether or not there is a change in the log odds of cluster membership in cluster 7 corresponding to a unit change in the hippocampus volume. The above data provided includes the hippocampus volume for each mouse.

```{r}
##Associations of cell-type proportions with hippocampus volume
design@condition_column = "Hippocampus_Vol_mm"
design@condition_is_categorical = FALSE
design@experimental_columns = c("animal_model", "sample_id")

diagnose_res <- diagnoseDataModel(data, design, model)

```

We can also estimate the parameter of interest - log odds ratio of cluster 7 membership per unit increase in hippocampus volume of associated mouse.

```{r}
estimate_res <- getEstimatesOfInterest(data, design, model)
print(estimate_res[[1]])
```

And calculate the statistical power to estimate this association for different numbers of animals per group.

```{r eval=TRUE}
power_res <- calculatePower(data, design, model, power_param)
```

### Gene expression associations with genotype
We will now estimate the association of the expression levels of the Snhg11 gene with genotype among cells in cluster 7 in the same data set. We will now load the raw counts for this gene and create the relevant RMeDesign, ProbabilityModel and PowerParams objects.

```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/single_cell_data/gene_expression_with_genotype/"

data <- read.csv(paste0(template_dir, "raw_counts_Snhg11_gene_cluster_7_snRNAseq_Koutsodendris_et_al_2023.csv"), header = T)
# data %<>% mutate(genotype = gsub(" ", "-", genotype))
# data %>% write.csv(., paste0(template_dir, "raw_counts_Snhg11_gene_cluster_7_snRNAseq_Koutsodendris_et_al_2023.csv"), row.names = F)
head(data)

design <- readDesign(paste0(template_dir,"design_gene_expression.json"))
print(design)

model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
print(model)

power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
print(power_param)
```

Note, we will assume the underlying probability distribution for the counts is negative binomial and will control for differences in the sequencing depths or the total reads each cell receives using `library_size`.

Diagnosis of the data and the model
```{r}
diagnose_res <- diagnoseDataModel(data, design, model)
```


Estimate log-fold change of the Snhg11 gene with genotype.
```{r}
estimate_res <- getEstimatesOfInterest(data, design, model)
print(estimate_res[[1]])
```
We can also perform a power analyses to detect a log(2) fold-change in this gene.

```{r eval = FALSE}
power_param@effect_size <- log(2)
power_res <- calculatePower(data, design, model, power_param)
```

## Behavior assays
Morris Water Maze (MWM) is an assay used to test spatial learning in animal models of diseases like Alzheimer's disease. The time recorded by each mouse to reach a target region (in the MWM) over multiple trials denoted as latency is the response of interest. Mouse models deficient in spatial learning would demonstrate an increased latency to reach a target region (invisible platform in Figure \@ref(fig:MWM)) across the learning trials.

```{r MWM, echo=FALSE, fig.align = "center", fig.cap='Morris Water Maze', fig.wide=TRUE, echo=FALSE}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/MorrisWaterMaze.svg/1920px-MorrisWaterMaze.svg.png")
```


```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/behavior_data/"
data <- read.csv(paste0(template_dir, "MWM_data.csv"), header = T)
design <- readDesign(paste0(template_dir,"design_behavior.json"))
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))


```

```{r}
diagnose_res <- diagnoseDataModel(data, design, model)
```
Based on the above plots, it seems like the log transformed versions of the latency responses better fit the model assumptions. Therefore using these transformed responses we will estimate and visualize our parameter of interest.
```{r}
data_update <- diagnose_res$Data_updated
design_update <- design
design_update@response_column %<>% paste0(., "_logTransformed")
estimate_res <- getEstimatesOfInterest(data_update, design_update, model)
print(estimate_res[[1]])
```
We will also perform sample-size calculations for the number of mice needed per cohort.
```{r eval=FALSE}
power_param@target_columns <- "MouseID"
power_res <- calculatePower(data_update, design_update, model, power_param)
```

## Brain electrical signal assays
Patch clamp is a technique that can be used to measure membrane action potential in excitable cells like neurons. We will work with (simulated) data from two sets of mice - one representing a Alzheimer's Disease model (hAPP) and the other representing control or wild-type mice. In each of these mice, multiple brain tissue slices are isolated and the membrane action potential for at least one neuronal cell in each slice is recorded.

```{r Patch, echo=FALSE, fig.align = "center", fig.cap='Patch clamp assay', fig.small=TRUE, echo=FALSE}
knitr::include_graphics("https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fs41598-017-05607-3/MediaObjects/41598_2017_5607_Fig1_HTML.jpg")
```

```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/electrical_patch_clamp_data/"
data <- read.csv(paste0(template_dir, "patch_clamp_data.csv"), header = T)
head(data)

design <- readDesign(paste0(template_dir,"design_patch_clamp.json"))
print(design)

model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
print(model)

power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
print(power_param)

```

We will now evaluate the model.

```{r}
diagnose_res <-diagnoseDataModel(data, design, model)
```

 It does not look like the log transformation resulted significantly changed how well the model assumptions were being met. We will estimate the association of genotype using the responses in their natural scale.
 
```{r}
estimate_res <- getEstimatesOfInterest(data, design, model)
print(estimate_res[[1]])
```

This is not significant at all. How many mice do we need to have 80% power to estimate the observed difference?

```{r eval=FALSE}

power_param@target_columns <- "Mice"
power_param@effect_size <- 7
power_res <- calculatePower(data, design, model, power_param)

power_param@target_columns <- "slice_number"
power_res <- calculatePower(data, design, model, power_param)

```
# Understanding simulations to estimate the power

`RMeDPower2` is designed to simulate the effect of variability of the responses which could come from differences in the  processing batch, plates or cell lines on the responses of interest the cell assay data (described above for exampel). There are several ways to assess the impact of different choices for the experimental variables in this package as outlined below.

First, a user can assess how increasing the number of independent experiments affects power. For example, if a user has a pilot dataset that consists of 3 experimental batches that each contain 2 plates, expanding this dataset two-fold would have the effect of simulating 6 experiments with a total of 12 plates (Figure \@ref(fig:exp) ). 

```{r exp, echo=FALSE, fig.align = "center", fig.cap="Example of RMeDPower’s simulation of experimental variability for 'experiment' for the power analysis. If level=1 is set, RMeDPower simulates the effect of adding in additional experiments by inheriting the experimental design structure from the existing data. This describes the situation where the pilot study involves data from 3 experiments, with 2 plates used per experiment, 3 cell lines within each plate and 12 cells per cell line are assayed.", fig.wide=TRUE, echo=FALSE , fig.topcaption=TRUE}
knitr::include_graphics("~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/Figures/J-Kaye_M-Shin 20222503_Part5.png")
```

In the code that tests power using the example data 'RMeDPower_data1', this scenario can be simulated by setting 'target_columns' to 'line' and 'levels' to 1 where 'line' corresponds to the cell line. The 'condition_column' of the data corresponds to 'classification' indicating the cell state, and there are two experimental variables: 'experiment' and 'line'. Since the same cell line may appear in multiple experiments,  "line" is treated as "repetable_column". "cell_size2" is used as 'response_column' for the simulation (Figure \@ref(fig:Sim1)).

```{r}

template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

##load the design
design <- readDesign(paste0(template_dir,"design_cell_assay_sim1.json"))
##load the probability model
model <- readProbabilityModel(paste0(template_dir,"prob_model_sim1.json"))
##load the relevant power parameters
power_param <- readPowerParams(paste0(template_dir,"power_param_sim1.json"))

print(design)
print(model)
print(power_param)


```

```{r eval=FALSE}

##calculate power
power_res <- calculatePower(RMeDPower_data1, design, model, power_param)

```

```{r Sim1, echo=FALSE, fig.align = "center", fig.cap='Sim1', fig.small=TRUE, echo=FALSE}
template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

knitr::include_graphics(paste0(template_dir,"RMeDPower2_ex1.jpg"))
```
In a similar context, users can evaluate power for a given number of experiments. To do this, we assign a value corresponding to the number of experiments to 'max_size' and set 'power_curve' to 0. We can set the 'output' variable to specify the output file name.

```{r}

template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

##load the design
design <- readDesign(paste0(template_dir,"design_cell_assay_sim3.json"))
##load the probability model
model <- readProbabilityModel(paste0(template_dir,"prob_model_sim3.json"))
##load the relevant power parameters
power_param <- readPowerParams(paste0(template_dir,"power_param_sim3.json"))

print(power_param)

```

```{r echo=FALSE}
load(file='/Users/mingyoungshin/git/RMeDPower/data/RMeDPower_data1.rda')
load(file='/Users/mingyoungshin/git/RMeDPower/data/RMeDPower_data2.rda')

##calculate power
power_res <- calculatePower(RMeDPower_data1, design, model, power_param)

print(power_res)
```

Alternatively, a user can assess how increasing the number of plates per experiment affects power. In the case where there are two experiments that each contain two plates, the user can double the number of plates used per experiment. In this way, the user can simulate how the statistical power changes as a result of increasing the number of plates used per experiment rather than increasing the number of experimental batches (Figure \@ref(fig:plate)). 

```{r plate, echo=FALSE, fig.align = "center", fig.cap="Example of RMeDPower’s simulation of plate variability for ‘plate' power analysis. If level=1 is set, RMeDPower simulates new plates by inheriting the experimental design structure from the existing data.", fig.wide=TRUE, echo=FALSE, fig.topcaption=TRUE}
knitr::include_graphics("~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/Figures/J-Kaye_M-Shin 20222503_Part7.png")
```

In a third example, a user can examine the effect of expanding the number of cell lines within each experiment affects power (Figure \@ref(fig:line)). This would capture the effect of increasing the number of cells assayed as a consequence of having more cell lines. 

```{r line, echo=FALSE, fig.align = "center", fig.cap="Example of RMeDPower’s simulation of cell line variability for ‘cell line' power analysis. If level=1 is set, RMeDPower simulates new cell lines by inheriting the experimental design structure from the existing data.", fig.wide=TRUE,  fig.topcaption=TRUE}
knitr::include_graphics("~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/Figures/J-Kaye_M-Shin 20222503_Part9.png")
```

Alternatively, one might want to assess the effect of increasing the total number of cells by increasing the number of cells per cell line (Figure \@ref(fig:lineCell)). 

```{r lineCell, echo=FALSE, fig.align = "center", fig.cap="Example of RMeDPower’s simulation of a sample size increase by increasing the number of cell line. If level=0 is set, RMeDPower multiplies the number of cells per cell line by M/N, where N is the maximum number of cells per cell line and M is a value assigned to the parameter ‘max_size’.", fig.wide=TRUE, echo=FALSE, fig.topcaption=TRUE}
knitr::include_graphics("~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/Figures/J-Kaye_M-Shin 20222503_Part10.png")
```

Tables 1-3, in addition to the figures, show the change in cell number after variable expansion in experiment, plate or cell line, especially when the cell distribution is asymmetric.
A user may want to examine the power of increasing the total number of cells measured from each experimental variable per experiment. For example, if there are 12 cells per cell line on plate 1, doubling the number of cells from each plate will result in assessing the effect in twice the number
of cells per cell line, even if the number of experiments and cell lines remain the same (Figure \@ref(fig:plateCell)). 

```{r plateCell, echo=FALSE, fig.align = "center", fig.cap="Example of RMeDPower’s simulation of a sample size increase for ‘plate' power analysis. If level=0 is set, RMeDPower multiplies the number of cells per plate by M/N, where N is the maximum number of cells per plate and M is a value assigned to the parameter ‘max_size’.", fig.wide=TRUE, fig.topcaption=TRUE}
knitr::include_graphics("~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/Figures/J-Kaye_M-Shin 20222503_Part8.png")
```

```{r echo=FALSE}
knitr::kable( rbind(c("(A)", "Cell line 1", "Cell line 2"),
             c("Exp 1", 3, 6),
             c("Exp 2", 3, 0),
             c("(B)", "Cell line 1", "Cell line2"),
             c("Exp 1", 3, 6),
             c("Exp 2", 3, 0),
             c("Exp 3", 3, 6),
             c("Exp 4", 3, 0)),
  caption="Example of changes in cell counts in a simulation of experimental batch variability. (A) Original data structure and (B) changed data structure after simulation. Simulation based on level=1 keeps the same structure and increases the number of experiments. This describes the situation where the pilot study involved 2 experiments, in the first experiment two cell lines are used with 3 and 6 cells assayed, respectively, and in the second experiment only 3 cells from the first experiment are assayed."
)
```

```{r echo=FALSE}
knitr::kable(rbind(c("(A)", "Cell line 1", "Cell line 2"),
            c("Plate 1", 4, 5),
            c("Plate 2", 2, 0),
            c("(B)", "Cell line 1", "Cell line 2"),
            c("Plate 1", 4, 5),
            c("Plate 2", 2, 0),
            c("Plate 1'", 4 ,5),
            c("Plate 2'", 2, 0)),
  caption="Example of changes in cell counts in a simulation of plate variability. (A) Original data structure and (B) changed data structure after simulation. Simulation based on level=1 keeps the same structure and increases the number of plates."
)
```

```{r echo=FALSE}
knitr::kable(rbind(c("(A)", "Cell line 1", "Cell line 2", "", "", "", ""),
            c("Exp 1", 3, 6, "", "", "", ""),
            c("Exp 2", 3, 0, "", "", "", ""),
            c("(B)", "Cell line 1a", "Cell line 2a", "Cell line 1b", "Cell line 2b", "Cell line 1c", "Cell line 2c"),
            c("Exp 1", 3, 6, 3, 6, 3, 6),
            c("Exp 2", 3, 0, 3, 0, 3, 0)),
  caption="Example of changes in cell counts in a simulation of cell line variability. (A) Original data structure and (B) changed data structure after simulation. If level=1 is set, RMeDPower simulates new cell lines by inheriting the experimental design structure from the existing data. An example of a simulation in tabular format shows the change in the number of cells per cell line and experiment after simulation. Simulation based on level=1 keeps the same structure and increases the number of cell lines."
)
```





Expansion results for plates and cell lines may differ if cells are asymmetrically distributed in different settings. Tables 4 and 5 show the different results users can get in an asymmetric distributed cell scenario. This type of variable expansion can be accomplished by setting ‘level=0’ in the calculate_power function.

```{r echo=FALSE}
knitr::kable(rbind(c("(A)", "Cell line 1", "Cell line2"),
            c("Plate 1", 3, 6),
            c("Plate 2", 3, 0),
            c("(B)", "Cell line 1", "Cell line 2"),
            c("Plate 1", 6, 12), 
            c("Plate 2", 6, 0)),
  caption="Example of plate-based cell count expansion simulation. (A) Original data structure and (B) changed data structure after simulation. The simulation is based on level=0 which results in increased number of cells per plate."
)
```

```{r echo=FALSE}
knitr::kable(rbind(c("(A)", "Cell line 1", "Cell line 2"),
            c("Exp 1", 3, 6),
            c("Exp 2", 3, 0),
            c("(B)", "Cell line 1", "Cell line 2"),
            c("Exp 1", 9, 18),
            c("Exp 2", 9, 0)),
  caption="Example of cell line-based cell count expansion simulation. (A) Original data structure and (B) changed data structure after simulation. An example of a simulation in tabular format shows the change in the number of cells per cell line and experiment after simulation. The simulation is based on level=0 which results in an increased number of cells per cell line."
)
```

The type of variable expansion shown in Table 3 and 5  can be accomplished by setting 'target_columns' to 'line' and 'levels' to 0. In the code example, we modified the maximum number of cell lines by setting 'max_size' to 700 (Figure \@ref(fig:Sim2)). 

```{r}

template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

##load the design
design <- readDesign(paste0(template_dir,"design_cell_assay_sim2.json"))
##load the probability model
model <- readProbabilityModel(paste0(template_dir,"prob_model_sim2.json"))
##load the relevant power parameters
power_param <- readPowerParams(paste0(template_dir,"power_param_sim2.json"))

print(power_param)

```

```{r eval=FALSE}

##calculate power
power_res <- calculatePower(RMeDPower_data1, design, model, power_param)

```

```{r Sim2, echo=FALSE, fig.align = "center", fig.cap='Sim2', fig.small=TRUE, echo=FALSE}
template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

knitr::include_graphics(paste0(template_dir,"RMeDPower2_ex2.jpg"))
```

We can also test the power of two experimental variables by assigning a vector of variable names to 'target_columns' (Figure\@ref(fig:Sim5)).

```{r}

template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

##load the design
design <- readDesign(paste0(template_dir,"design_cell_assay_sim5.json"))
##load the probability model
model <- readProbabilityModel(paste0(template_dir,"prob_model_sim5.json"))
##load the relevant power parameters
power_param <- readPowerParams(paste0(template_dir,"power_param_sim5.json"))

print(power_param)

```

```{r eval=FALSE}

##calculate power
power_res <- calculatePower(RMeDPower_data1, design, model, power_param)

```

```{r Sim5, echo=FALSE, fig.align = "center", fig.cap='Sim5', fig.small=TRUE, echo=FALSE}
template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

knitr::include_graphics(paste0(template_dir,"RMeDPower2_ex5a.jpg"))
knitr::include_graphics(paste0(template_dir,"RMeDPower2_ex5b.jpg"))
```

Our power simulations depend on the variance components estimated from the input dataset. However, in some cases there may not be enough data to estimate the variance component. For example, the pilot data might have only a single category for 'experimental batch', ‘plate’ or 'line'. When this occurs, the user needs to provide ICC values. These values can be estimated from another dataset for which the variance components are assumed to be similar to those inherent for the new response being considered in the input dataset. ICC can be estimated by taking the ratio between the variance estimates using the following formula:

〖ICC〗_i=V_i/(∑_(j∈S)▒〖V_i+e〗) 
                                                                                                                                                             
 where V_i represents the variance of the random effect linked to experimental variable (e.g., experimental batch, plate or cell-line) i, and epsilon represents the variance of the residual error. S represents all the modeled sources of variability of the response under consideration. We will test this scenario using the example RMeDPower_data2 with only single experiment and cell line. To test power in scenarios with varying number of experiments, we set the ‘icc’ parameter to 0.8, 0.05, 0.05. (Figure\@ref(fig:Sim6)).

```{r}

template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

##load the design
design <- readDesign(paste0(template_dir,"design_cell_assay_sim6.json"))
##load the probability model
model <- readProbabilityModel(paste0(template_dir,"prob_model_sim6.json"))
##load the relevant power parameters
power_param <- readPowerParams(paste0(template_dir,"power_param_sim6.json"))

#print(design)
#print(model)
print(power_param)


```

```{r eval=FALSE}

##calculate power
power_res <- calculatePower(RMeDPower_data2, design, model, power_param)

```

```{r Sim6, echo=FALSE, fig.align = "center", fig.cap='Sim6', fig.small=TRUE, echo=FALSE}
template_dir="~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/tutorial_session3/"

knitr::include_graphics(paste0(template_dir,"RMeDPower2_ex6.jpg"))

```

<!-- # Equations -->

<!-- To number and reference equations, put them in equation environments and assign labels to them, see Equation \@ref(eq:binom). -->

<!-- \begin{equation} -->
<!--   f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k} -->
<!--   (\#eq:binom) -->
<!-- \end{equation} -->


<!-- # Tables -->

<!-- Like figures, tables with captions will also be numbered and can be referenced, see Table \@ref(tab:table). -->

<!-- Fruit   | Price -->
<!-- ------- | ----- -->
<!-- bananas | 1.2 -->
<!-- apples  | 1.0 -->
<!-- oranges | 2.5 -->

<!-- : (\#tab:table) A simple table. With caption. -->


<!-- # Cross-references -->

<!-- Apart from referencing figures (Section \@ref(figures)), tables (Section \@ref(tables)), and equations (Section \@ref(equations)), you can also use the same syntax to refer to sections by their default labels generated by pandoc. -->


<!-- # Side notes -->

<!-- Footnotes are displayed as side notes on the right margin^[this is a side note entered as a footnote], which has the advantage that they appear close to the place where they are defined. -->

# References {.unnumbered}


# Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
