---
title: "*RMeDPower2*: helping design and analyses of data from repeated measures experiments" 
author:
- name: Min-Gyoung Shin
  affiliation: Gladstone Institutes
  email: mingyoung.shin@gladstone.ucsf.edu
- name: Reuben Thomas
  affiliation: Gladstone Institutes
  email: reuben.thomas@gladstone.ucsf.edu
package: RMeDPower
output:
  BiocStyle::html_document
abstract: |
  Biomedical research very often involves data generated from repeated measures experiments. RMeDPower2 is an R package that provides complete functionality to analyse data coming from repeated measures experiments, i.e., where one has repeated measures from the same biological/independent units or samples. RMeDPower2 helps test the modeling assumptions one makes, identify outlier observations, outlier units at different levels of the design, estimates statistical power or perform sample size calculations, estimate parameters of interest and also to visualize the association being tested. The functionality is limited to testing associations of one predictor (continuous or categorical, e.g., disease status or brain pathology) along with one another covariate (e.g., gender status) in the context of hierarchical or crossed experimental designs. This vignette illustrates the use of this package in multiple contexts relevant to biomedical research. 
  
  RMeDPower2 defines the experimental design for the data, probability model of the data generating distribution and necessary parameters required for sample size calculation using convenient S4 class objects. It uses these objects in one framework that brings together the functionality implemented in multiple R packages - lme4 (implementation of linear mixed effects models), influence.ME (identification of outlier units), EnvStats (identification of outlier observations), DHARMa (testing of modeling assumptions), simr (sample-size calculations) and tidyverse (data manipulation and visualization).
vignette: |
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Getting started

## Quick tutorial
The workflow can be accomplished in 5 main steps.

### Input data
Read-in the input data as a data frame
```{r}
library(RMeDPower2)
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/cell_assay_data/"

data <- read.csv(paste0(template_dir, "cell_size_data.csv"), header = T)
```


### Specify design, model and power parameters
1. Use a text editor to modify the template jsonfile capturing the design file and read in this file.
```{r}
design <- readDesign(paste0(template_dir,"design_cell_assay.json"))
```
2. Use a text editor to modify the template jsonfile capturing the error probability model file and read in this file.
```{r}
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
```
3. Use a text editor to modify the template jsonfile capturing the power parameters file and read in this file.
```{r}
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
```

### Diagnose data and model
1. Diagnose the data and model, test model assumptions, identify outlier observations, outlier biological/independent units
```{r eval=FALSE}
diagnose_res <- diagnoseDataModel(data, design, model)
```
2. Modify design objects (e.g., remove outliers), model objects (e.g., change probability distribution assumption) if needed based on output of step 1 above.
```{r eval=FALSE}
diagnose_res_update <- diagnoseDataModel(data_update, design_update, model_update)
```
3. Repeat steps 1 and 2 until the models assumptions are met

### Statistical power estimation
Run sample-size calculations
```{r eval=FALSE}
power_res <- calculatePower(data, design, model, power_param)
```

### Estimate parameters of interest
Estimate and visualize parameters of interest.
```{r eval=FALSE}
estimate_res <- getEstimatesOfInterest(data, design, model)
```
## Input data
Users will have to ensure that the input data is a table with rows representing the  individual observations or responses and columns representing not only the corresponding predictor/independent variables but also other variables that capture the hierarchical or crossed design of how the data was generated. It is important that the columns have names or headers - these column names will be used to define the relevant S4 class objects. 

For example, below illustrates the input data from a cellular assay where each of the 2,588 observations represents a measurement of size (`cell_size2`) of a single cell, from a given cell line (`line`) that is either from a control or disease condition (`classification`) and is measured in a given experimental batch (`experiment`).

```{r echo=FALSE} 
suppressPackageStartupMessages(require(dplyr)) 
suppressPackageStartupMessages(library(RMeDPower2))
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/cell_assay_data/"

data <- read.csv(paste0(template_dir, "cell_size_data.csv"), header = T) %>%
  select(experiment, line, classification, cell_size2) %>%
  mutate(experiment = as.factor(experiment), line = as.factor(line), classification = as.factor(classification))

str(data)
```

## `RMeDesign` S4 class
The underlying design for the data will be stored in an object of this class. The slots of this class are:

1. `response_column`: character that is the column name in the input data table that captures the responses or individual observations. This has to be set by the user.

2. `covariate`: character that is the column name in the input data table that captures the covariate information. This will be used as a fixed effect in the mixed effects model of the data. This slot is set to `NULL` if there are no covariates.

3. `condition_column`: character that is the column name in the input data table that captures the predictor/independent variable information. This will be used as a fixed effect in the mixed effects model of the data.This has to be set by the user.

4. `experimental_columns`: character vector that represents the column names in the input data table that captures the experimental variables of the design. These will be used as random effects in the mixed effects model of the data. The order of the names in this character vector is important. The first element captures the top hierarchical level of the design, the second element the next level of the hierarchy and so on. The hierarchy is explicitly modeled in the specification of the mixed effects models. The hierarchy will not be modeled for variables specified in the `crossed_columns` slot (see below). This has to be set by the user. 

5. `condition_is_categorical`: logical value equal to TRUE if the variable in the `condition_column` is to be considered as a categorical variable and is equal to FALSE otherwise. Defaults to TRUE.

6. `crossed_columns`: character vector that represents the column names in the input data table that are a subset of the values in `experimental_columns` representing crossed factors. Defaults to `NULL`.

7. `total_column`: character that is the column name in the input table that will be used to offset values in the mixed effects models. Useful for modeling count data. Defaults to `NULL`.
  
8. `outlier_alpha`: numeric value that is the p-value threshold used to identify outlier observations. Defaults to 0.05. 

9. `na_action`: character equal to _complete_ or _unique_. To be used in the context where the input data has multiple responses that will each be sequentially modeled. _complete_ refers to the situation where outlier observations identified for one response will also be identified as outliers for all the other responses while _unique_ refers to the situation where the outlier observations identified for one response will only be used for the model of that particular response. Defaults to _complete_.

We can create an object of class `RMeDesign` using the function.
```{r}
design <- new("RMeDesign")
print(design)
```

In practice, for a given data set the design can be input from a jsonfile. The user can use a text editor to modify the `design_template.json` file available with the package to input the relevant information based on the column names of the input data. For example, the design for the cell size data referred to above can be read using the function `readDesign`,
```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/cell_assay_data/"

design <- readDesign(paste0(template_dir,"design_cell_assay.json"))
print(design)
```
## `ProbabilityModel` S4 class
The error probability distribution is specified by two slots in objects of the `ProbabilityModel` class.

1. `error_is_non_normal`: logical value that is TRUE if the underlying probability distribution is not assumed to be Normal and is FALSE otherwise.

2. `family_p`: character value that specifies the probability distribution. Accepted values are _poisson_(`=poisson(link="log")`), _binomial_(`=binomial(link="logit")`), _bionomial_log_(`=binomial(link="log")`), _Gamma_log_(`=Gamma(link="log")`), _Gamma_(`=Gamma(link="inverse")`). Defaults to `NULL`.

```{r}
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
print(model)
```
## `PowerParams` S4 class
The parameters necessary for sample-size estimation are stored in the following slots of the `PowerParams` class.

 1. `target_columns`: character vector with column names of experimental variables for which the sample-size estimation is to be performed
2. `power_curve`: numeric 1 or 0. 1: Power simulation over a range of sample sizes or levels. 0: Power calculation over a single sample size or a level. Defaults to 1.
3. `nsimn`: The number of simulations to estimate power. Defaults to 10.
4. `levels`: numeric 1 or 0. 1: Amplify the number of corresponding target parameter. 0: Amplify the number of samples from the corresponding target parameter, ex) If target_columns = c("experiment","cell_line") and if you want to expand the number of experiment and sample more cells from each cell line, set levels = c(1,0).
5. `max_size`: Maximum levels or sample sizes to test. Default if set to `NULL` equals the current level or the current sample size x 5. ex) If max_levels = c(10,5), it will test upto 10 experiments and 5 cell lines.
6. `alpha`: Type I error for sample-size estimation. Defaults to 0.05.
7. `breaks`: Levels /sample sizes of the variable to be specified along the power curve. Default if set to `NULL` equals max(1, round( the number of current levels / 5 ))
8. `effect_size`: If you know the effect size of your condition variable, the effect size can be provided as a parameter. Default set to `NULL`, that is, if the effect size is not provided, it will be estimated from your data,
9. `icc`: Intra-class coefficients for each of the experimental variables. Used only in the situation when `error_is_non_normal=FALSE` and when the data does not allow variance component estimation 

```{r}
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
print(power_param)
```



# Application examples
## Plate assays
```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/cell_assay_data/"

data <- read.csv(paste0(template_dir, "cell_size_data.csv"), header = T)
design <- readDesign(paste0(template_dir,"design_cell_assay.json"))
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
```

Diagnose the data and the model
```{r}
diagnose_res <- diagnoseDataModel(data, design, model)
```

Check for outlier experimental batches
```{r}
##see which experimental columns correspond to which variable
print(design@experimental_columns)
print(diagnose_res$cooks_distance_experimental_column1)
```

It looks like `experiment3` batch seems like an outlier. Now, check for outlier cell lines
```{r}
print(diagnose_res$cooks_distance_experimental_column2)
```

The qq plots of the residuals resulting from log transformation of the cell-size responses and the removal of outliers seems to deviate least from normality (though they still do seem non-normal). In any case, we will use these data for parameter estimation. 

```{r}
design_update <- design
data_update <- diagnose_res$Data_updated
print(colnames(data_update))
design_update@response_column <-  "cell_size2_logTransformed_noOutlier"
estimate_res <- getEstimatesOfInterest(data_update, design_update, model)
##print model summary output
print(estimate_res[[1]])
```
### Sample-size estimation: Example 1
```{r eval=FALSE}
power_res <- calculatePower(data_update, design_update, model, power_param)
```

### Example 2
duhjjp hojo

## single-cell assays
We will use data derived from the single-nuclei RNA-seq experiments performed in Koutsodendris et al. paper. One of the goals in these experiments was to assess the effect of the APOE gene isoform on brain pathology in a mouse model of Alzheimer's Disease (AD). Specifically, APOE4 gene isoform is an known risk factor for this disease in humans compared to those with the APOE3 gene isoform. The design of the data involved order 1000 cells derived from the hippocampus brain region of 3 mice with the human APOE3 gene knocked-in the mouse Apoe locus and 4 other mice with the human APOE4 gene knocked-in. The single cell data allowed the identification of multiple clusters or cell-types including cluster 7 representing a group of excitatory neurons consisted of nuclei.

### Between cluster association
We can first ask the question whether or not the proportion of nuclei derived from the APOE4-KI mice are different in cluster 7 compared to those derived from the APOE3-KI mice. More exactly, we want to test whether or not there is a difference in the log odds of cluster membership in cluster 7 among the APOE4-KI mice versus the APOE3-KI. The data consists of the number of nuclei per animal present in the cluster and also the total number of nuclei that were isolated from this animal.

#### Association with genotype
```{r}
template_dir <- "~/Dropbox (Gladstone)/calcPower f1000_manuscript/Final_paper_materials/Revisions/input_templates/single_cell_data/celltype_proportions_with_genotype/"
data <- read.csv(paste0(template_dir, "apoe_associated_cell_proportions.csv"), header = T)
head(data)

##load the design
design <- readDesign(paste0(template_dir,"design_celltype1.json"))
print(design)

##load the probability model
model <- readProbabilityModel(paste0(template_dir,"prob_model.json"))
print(model)

##load the relevant power parameters
power_param <- readPowerParams(paste0(template_dir,"power_param.json"))
print(power_param)
```


Now, we will diagnose the data and the model.
```{r}
diagnose_res <- diagnoseDataModel(data, design, model)
```

We can now estimate the log odds ratio of interest.
```{r}
estimate_res <- getEstimatesOfInterest(data, design, model)
print(estimate_res[[1]])
```
### Within cluster association
duhjjp hojo

## behavior assay

# Figures

Assign captions to figures in the code chunk option `fig.cap` to automatically number them, and to be able to reference them, see Figure \@ref(fig:plot). The figure label is generated from the code chunk label by prefixing it with `fig:`.

```{r plot, fig.cap="Regular figure. The first sentence of the figure caption is automatically emphasized to serve as figure title.", echo=FALSE}
plot(cars)
```

Small and wide figures can be specified by `fig.small` and `fig.wide` code chunk options.

```{r small, fig.cap="Small figure. A plot produced by a code chunk with option `fig.small = TRUE`.", fig.small=TRUE, echo=FALSE}
plot(cars)
```

```{r wide, fig.cap="Wide figure. A plot produced by a code chunk with option `fig.wide = TRUE`.", fig.wide=TRUE, echo=FALSE}
plot(cars)
```


# Equations

To number and reference equations, put them in equation environments and assign labels to them, see Equation \@ref(eq:binom).

\begin{equation}
  f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k}
  (\#eq:binom)
\end{equation}


# Tables

Like figures, tables with captions will also be numbered and can be referenced, see Table \@ref(tab:table).

Fruit   | Price
------- | -----
bananas | 1.2
apples  | 1.0
oranges | 2.5

: (\#tab:table) A simple table. With caption.


# Cross-references

Apart from referencing figures (Section \@ref(figures)), tables (Section \@ref(tables)), and equations (Section \@ref(equations)), you can also use the same syntax to refer to sections by their default labels generated by pandoc.


# Side notes

Footnotes are displayed as side notes on the right margin^[this is a side note entered as a footnote], which has the advantage that they appear close to the place where they are defined.

# References {.unnumbered}


# Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
